"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const abab_1 = require("abab");
const utils_1 = require("@hint/utils");
const utils_connector_tools_1 = require("@hint/utils-connector-tools");
const debug = utils_1.debug(__filename);
const { getContentTypeData } = utils_1.contentType;
var RequestStatus;
(function (RequestStatus) {
    RequestStatus["willBeSent"] = "willBeSent";
    RequestStatus["responseReceived"] = "responseReceived";
    RequestStatus["loadingFinished"] = "loadingFinished";
    RequestStatus["loadingFailed"] = "loadingFailed";
})(RequestStatus = exports.RequestStatus || (exports.RequestStatus = {}));
class RequestResponse {
    constructor(network, event, ignoreHTTPSErrors) {
        this._hops = [];
        this._network = network;
        this._status = RequestStatus.willBeSent;
        this._willBeSent = event;
        this._requestId = event.requestId;
        this._originalUrl = event.request.url;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
    }
    get requestId() {
        return this._requestId;
    }
    get status() {
        return this._status;
    }
    get hops() {
        return this._hops;
    }
    get originalUrl() {
        return this._originalUrl;
    }
    get finalUrl() {
        return this.willBeSent.request.url;
    }
    get willBeSent() {
        return this._willBeSent;
    }
    get responseReceived() {
        return this._responseReceived;
    }
    get loadingFinished() {
        return this._loadingFinished;
    }
    get loadingFailed() {
        return this._loadingFailed;
    }
    get responseBody() {
        return this._responseBody;
    }
    fetchContent(href, headers) {
        const options = {
            headers,
            rejectUnauthorized: !this._ignoreHTTPSErrors,
            strictSSL: !this._ignoreHTTPSErrors
        };
        const request = new utils_connector_tools_1.Requester(options);
        return request.get(href);
    }
    getRawResponse() {
        const that = this;
        if (this._rawResponse) {
            return Promise.resolve(this._rawResponse);
        }
        const { rawContent } = this._response.body;
        if (rawContent && rawContent.length.toString() === this._responseReceived.response.headers['Content-Length']) {
            return Promise.resolve(rawContent);
        }
        const { url: responseUrl, requestHeaders: headers } = this._responseReceived.response;
        const validHeaders = Object.entries(headers || {}).reduce((final, [key, value]) => {
            if (key.startsWith(':')) {
                return final;
            }
            final[key] = value;
            return final;
        }, {});
        return this.fetchContent(responseUrl, validHeaders)
            .then((result) => {
            const { response: { body: { rawResponse: rr } } } = result;
            return rr();
        })
            .then((value) => {
            that._rawResponse = value;
            return value;
        });
    }
    getResponse(element) {
        if (!this._response) {
            const { headers, status } = this.responseReceived.response;
            const normalizedHeaders = utils_connector_tools_1.normalizeHeaders(headers);
            const that = this;
            let rawContent = Buffer.alloc(0);
            let rBody = {
                content: '',
                rawContent,
                rawResponse: () => {
                    return Promise.resolve(Buffer.alloc(0));
                }
            };
            if (this._responseBody) {
                const { body, base64Encoded } = this._responseBody;
                const encoding = base64Encoded ? 'base64' : 'utf-8';
                const content = base64Encoded ? abab_1.atob(body) : body;
                rawContent = Buffer.from(body, encoding);
                rBody = {
                    content,
                    rawContent,
                    rawResponse: () => {
                        return that.getRawResponse();
                    }
                };
            }
            this._response = {
                body: rBody,
                charset: null,
                headers: normalizedHeaders,
                hops: this.hops,
                mediaType: null,
                statusCode: status,
                url: this.finalUrl
            };
            const { charset, mediaType } = getContentTypeData(element, this.originalUrl, normalizedHeaders, rawContent);
            this._response.mediaType = mediaType;
            this._response.charset = charset;
        }
        return this._response;
    }
    logInfo(message) {
        debug(`(${this._requestId}) ${message}`);
    }
    updateRequestWillBeSent(event) {
        if (event.redirectResponse) {
            this._hops.push(event.redirectResponse.url);
        }
        this._willBeSent = event;
        this.logInfo(RequestStatus.willBeSent);
    }
    updateResponseReceived(event) {
        this._responseReceived = event;
        this._status = RequestStatus.responseReceived;
        this.logInfo(RequestStatus.responseReceived);
    }
    async updateLoadingFinished(event) {
        if (!this._loadingFinished) {
            this._loadingFinished = event;
            this._status = RequestStatus.loadingFinished;
            this.logInfo(RequestStatus.loadingFinished);
        }
        else {
            this.logInfo(`${RequestStatus.loadingFinished} already set`);
        }
        try {
            if (this._responseBody) {
                this.logInfo(`Got body already`);
                return;
            }
            this.logInfo(`Getting body`);
            this._responseBody = await this._network.getResponseBody({ requestId: event.requestId });
            this.logInfo(`Got body`);
        }
        catch (e) {
            this.logInfo(`Error getting body`);
            this.logInfo(e);
        }
    }
    updateLoadingFailed(event) {
        this._loadingFailed = event;
        this._status = RequestStatus.loadingFailed;
        this.logInfo(RequestStatus.loadingFailed);
    }
}
exports.RequestResponse = RequestResponse;
