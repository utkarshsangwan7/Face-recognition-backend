"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const util_1 = require("util");
const cdp = require("chrome-remote-interface");
const lockfile = require("lockfile");
const filter = require("lodash/filter");
const utils_1 = require("@hint/utils");
const utils_connector_tools_1 = require("@hint/utils-connector-tools");
const request_response_1 = require("./request-response");
const { createHTMLDocument, getElementByUrl, traverse } = utils_1.dom;
const { getType } = utils_1.contentType;
const { cutString, delay } = utils_1.misc;
const { isHTMLDocument } = utils_1.network;
const debug = utils_1.debug(__filename);
const lock = util_1.promisify(lockfile.lock);
const unlock = util_1.promisify(lockfile.unlock);
class Connector {
    constructor(engine, config, launcher) {
        this._href = '';
        this._finalHref = '';
        this._errorWithPage = false;
        this._tabs = [];
        this._lockFile = 'cdp.lock';
        this._isLocked = false;
        const defaultOptions = {
            ignoreHTTPSErrors: false,
            waitFor: 5000
        };
        this._server = engine;
        this._timeout = engine.timeout;
        this._options = Object.assign({}, defaultOptions, config);
        this._requests = new Map();
        this._pendingResponseReceived = [];
        this._launcher = launcher;
        this._waitForTarget = new Promise((resolve) => {
            this._targetReceived = resolve;
        });
        engine.on('parse::end::html', (event) => {
            if (!this._originalDocument) {
                this._originalDocument = event.document;
            }
        });
    }
    getElementFromRequest(requestId, dom) {
        const sourceRequest = this._requests.get(requestId);
        if (!sourceRequest) {
            return null;
        }
        const { initiator: { type } } = sourceRequest.willBeSent;
        const requestUrl = sourceRequest.originalUrl;
        if (['parser', 'other'].includes(type) && requestUrl.startsWith('http')) {
            return getElementByUrl(dom, requestUrl);
        }
        return null;
    }
    async onRequestWillBeSent(params) {
        const { requestId } = params;
        let requestResponse;
        if (this._requests.has(requestId)) {
            requestResponse = this._requests.get(requestId);
            requestResponse.updateRequestWillBeSent(params);
        }
        else {
            requestResponse = new request_response_1.RequestResponse(this._client.Network, params, this._options.ignoreHTTPSErrors);
            this._requests.set(requestId, requestResponse);
        }
        const requestUrl = params.request.url;
        debug(`About to start fetching ${cutString(requestUrl)} (${params.requestId})`);
        const eventName = this._href === requestUrl ? 'fetch::start::target' : 'fetch::start';
        await this._server.emitAsync(eventName, { resource: requestUrl });
    }
    async onLoadingFailed(params) {
        const { requestId } = params;
        const requestResponse = this._requests.get(requestId);
        if (!requestResponse) {
            debug(`(${params.requestId}) Couldn't find associated "RequestResponse", skipping loadingFailed`);
            return;
        }
        const resource = requestResponse.finalUrl;
        if (resource === this._href || resource === this._finalHref) {
            this._errorWithPage = true;
            return;
        }
        if (!this._dom) {
            this._pendingResponseReceived.push(this.onLoadingFailed.bind(this, params));
            return;
        }
        if (requestResponse.responseReceived) {
            debug(`(${params.requestId}) Error handled during "responseReceived", skipping loadingFailed`);
            return;
        }
        requestResponse.updateLoadingFailed(params);
        debug(`Error found loading ${resource}:\n%O`, params);
        const element = this.getElementFromRequest(params.requestId, this._dom);
        const eventName = 'fetch::error';
        const hops = requestResponse.hops;
        const event = {
            element,
            error: params,
            hops,
            resource
        };
        await this._server.emitAsync(eventName, event);
    }
    async emitFetchEnd(requestResponse, dom) {
        const resourceUrl = requestResponse.finalUrl;
        const hops = requestResponse.hops;
        const originalUrl = hops[0] || resourceUrl;
        let element = null;
        const isTarget = !dom;
        if (dom) {
            try {
                element = await this.getElementFromRequest(requestResponse.requestId, dom);
            }
            catch (e) {
                debug(`Error finding element for request ${requestResponse.requestId}. element will be null`);
            }
        }
        const response = requestResponse.getResponse(element);
        if (!requestResponse.responseReceived) {
            const message = `Trying to emit "fetch::end" but no responseReceived for ${requestResponse.requestId} found`;
            throw new Error(message);
        }
        const request = {
            headers: utils_connector_tools_1.normalizeHeaders(requestResponse.responseReceived.response.requestHeaders),
            url: originalUrl
        };
        const data = {
            element,
            request,
            resource: resourceUrl,
            response
        };
        if (isTarget) {
            this._targetNetworkData = {
                request,
                response
            };
            this._targetReceived();
        }
        let suffix = getType(response.mediaType);
        const defaults = ['unknown', 'xml'];
        if (isTarget && defaults.includes(suffix)) {
            suffix = 'html';
        }
        const eventName = `fetch::end::${suffix}`;
        if (suffix === 'manifest') {
            return;
        }
        await this._server.emitAsync(eventName, data);
    }
    async onResponseReceived(params) {
        const { requestId } = params;
        const requestResponse = this._requests.get(requestId);
        if (!requestResponse) {
            debug(`(${requestId}) ResponseReceived but no requestWillBeSent found`);
            return;
        }
        if (!requestResponse.responseReceived) {
            requestResponse.updateResponseReceived(params);
        }
        if (!this._dom) {
            this._pendingResponseReceived.push(this.onResponseReceived.bind(this, params));
            return;
        }
        if (params.response.status === 200) {
            return;
        }
        await this.emitFetchEnd(requestResponse, this._dom);
    }
    async onLoadingFinished(params) {
        const { requestId } = params;
        const requestResponse = this._requests.get(requestId);
        if (!requestResponse) {
            debug(`(${requestId}) LoadingFinished but no requestWillBeSent found`);
            return;
        }
        await requestResponse.updateLoadingFinished(params);
        const resourceUrl = requestResponse.finalUrl;
        const hops = requestResponse.hops;
        const originalUrl = hops[0] || resourceUrl;
        const isTarget = this._href === originalUrl;
        if (isTarget) {
            await this.emitFetchEnd(requestResponse, null);
            return;
        }
        if (!this._dom) {
            this._pendingResponseReceived.push(this.onLoadingFinished.bind(this, params));
            return;
        }
        await this.emitFetchEnd(requestResponse, this._dom);
    }
    getClient(port, tab) {
        let retries = 0;
        const loadCDP = async () => {
            try {
                const client = await cdp({ port, tab });
                return client;
            }
            catch (err) {
                if (retries > 3) {
                    throw err;
                }
                await delay((retries * 250) + 500);
                retries++;
                return loadCDP();
            }
        };
        return loadCDP();
    }
    async lockFile() {
        try {
            debug(`Trying to acquire lock`);
            await lock(this._lockFile, {
                pollPeriod: 500,
                retries: 20,
                retryWait: 1000,
                stale: 50000,
                wait: 50000
            });
            this._isLocked = true;
            debug(`Lock acquired`);
        }
        catch (e) {
            {
                debug(`Error while locking`, e);
                throw e;
            }
        }
    }
    async unlockFile() {
        if (this._isLocked) {
            debug(`Trying to unlock`);
            await unlock(this._lockFile);
            debug(`Unlock successful`);
        }
        else {
            debug(`No need to unlock`);
        }
    }
    async initiateComms() {
        await this.lockFile();
        const launcher = await this._launcher.launch('about:blank');
        let client;
        this._pid = launcher.pid;
        if (launcher.isNew) {
            const tabs = filter(await cdp.List({ port: launcher.port }), (tab) => {
                return !tab.url.startsWith('chrome-extension');
            });
            client = await this.getClient(launcher.port, tabs[0]);
            this._tabs = tabs;
        }
        else {
            const tab = await cdp.New({ port: launcher.port, url: null });
            if (!tab) {
                throw new Error('Error trying to open a new tab');
            }
            this._tabs.push(tab);
            client = await cdp({
                port: launcher.port,
                tab: (tabs) => {
                    for (let index = 0; index < tabs.length; index++) {
                        if (tabs[index].id === tab.id) {
                            return index;
                        }
                    }
                    return -1;
                }
            });
        }
        await this.unlockFile();
        return client;
    }
    onError(err) {
        debug(`Error: \n${err}`);
    }
    async onDisconnect() {
        debug(`Disconnected`);
        await this.unlockFile();
    }
    async enableNetworkEvents() {
        debug('Binding to Network events');
        const { Network } = this._client;
        await Promise.all([
            Network.clearBrowserCache(),
            Network.setCacheDisabled({ cacheDisabled: true }),
            Network['requestWillBeSent'](this.onRequestWillBeSent.bind(this)),
            Network['responseReceived'](this.onResponseReceived.bind(this)),
            Network['loadingFinished'](this.onLoadingFinished.bind(this)),
            Network['loadingFailed'](this.onLoadingFailed.bind(this))
        ]);
    }
    async configureAndEnableCDP() {
        const { Network, Page } = this._client;
        this._client.on('error', this.onError.bind(this));
        this._client.on('disconnect', this.onDisconnect.bind(this));
        await this.enableNetworkEvents();
        await Promise.all([
            Network.enable({}),
            Page.enable()
        ]);
    }
    async getFavicon(dom) {
        const element = (await dom.querySelectorAll('link[rel~="icon"]'))[0];
        const href = (element && element.getAttribute('href')) || '/favicon.ico';
        try {
            debug(`resource ${href} to be fetched`);
            const fullFaviconUrl = dom.resolveUrl(href);
            await this._server.emitAsync('fetch::start', { resource: fullFaviconUrl });
            const content = await this.fetchContent(new url_1.URL(fullFaviconUrl));
            const data = {
                element: null,
                request: content.request,
                resource: content.response.url,
                response: content.response
            };
            await this._server.emitAsync('fetch::end::image', data);
        }
        catch (error) {
            const event = {
                element,
                error,
                hops: [],
                resource: href
            };
            await this._server.emitAsync('fetch::error', event);
        }
    }
    async processPendingResponses() {
        const promises = [];
        while (this._pendingResponseReceived.length) {
            debug(`Pending requests: ${this._pendingResponseReceived.length}`);
            promises.push(this._pendingResponseReceived.shift()());
        }
        await Promise.all(promises);
    }
    onLoadEventFired(callback) {
        return async () => {
            try {
                if (this._errorWithPage) {
                    return callback(new Error(`Problem loading the website ${this._href}`));
                }
                await this._waitForTarget;
                if (this._options.waitFor) {
                    await delay(this._options.waitFor);
                    this._client.Network.disable();
                }
                const event = { resource: this._finalHref };
                if (!isHTMLDocument(this._finalHref, this.headers)) {
                    await this._server.emitAsync('scan::end', event);
                    return callback();
                }
                const node = await this._client.DOM.getDocument({ depth: -1 });
                const html = (await this._client.DOM.getOuterHTML({ nodeId: node.root.nodeId })).outerHTML;
                const dom = createHTMLDocument(html, this._finalHref, this._originalDocument);
                this._dom = dom;
                await this.processPendingResponses();
                await traverse(dom, this._server, node.root.documentURL || this._finalHref);
                if (this._launcher.options &&
                    this._launcher.options.flags &&
                    this._launcher.options.flags.includes('--headless')) {
                    await this.getFavicon(this._dom);
                }
                await this._server.emitAsync('can-evaluate::script', event);
                return setTimeout(async () => {
                    await this._server.emitAsync('scan::end', event);
                    return callback();
                }, 1000);
            }
            catch (err) {
                return callback(err);
            }
        };
    }
    collect(target) {
        if (!target.protocol.match(/https?:/)) {
            const err = {
                message: `Protocol "${target.protocol}" invalid for the current collector`,
                type: 'InvalidTarget'
            };
            throw err;
        }
        return util_1.promisify(async (callback) => {
            this._href = target.href.replace(target.hash, '');
            this._finalHref = target.href;
            const event = { resource: target.href };
            let client;
            await this._server.emit('scan::start', event);
            try {
                client = await this.initiateComms();
            }
            catch (e) {
                debug('Error connecting to browser\n%O', e);
                callback(e, null);
                return;
            }
            this._client = client;
            const { Page, Security } = client;
            if (this._options.ignoreHTTPSErrors) {
                Security.certificateError(({ eventId }) => {
                    Security.handleCertificateError({
                        action: 'continue',
                        eventId
                    });
                });
                await Security.enable();
                await Security.setOverrideCertificateErrors({ override: true });
            }
            const loadHandler = this.onLoadEventFired(callback);
            this._client.once('Page.loadEventFired', loadHandler);
            try {
                await this.configureAndEnableCDP();
                await Page.navigate({ url: target.href });
            }
            catch (e) {
                await this._server.emitAsync('scan::end', event);
                callback(e, null);
                return;
            }
        })();
    }
    async close() {
        try {
            debug(`Closing connector (${this._pid})`);
            await this.lockFile();
            const { targetInfos } = await this._client.Target.getTargets();
            const targets = new Set();
            debug(`Pending targets: ${targetInfos.length}`);
            targetInfos.forEach((target) => {
                if (target.type === 'page') {
                    targets.add(target.targetId);
                }
            });
            while (this._tabs.length > 0) {
                debug(`Pending tabs: ${this._tabs.length}`);
                const tab = this._tabs.pop();
                try {
                    if (targets.has(tab.id)) {
                        targets.delete(tab.id);
                        debug(`(${tab.id}) Closing target`);
                        await cdp.Close({ id: tab.id, port: this._client.port });
                        debug(`(${tab.id}) Target closed`);
                    }
                }
                catch (e) {
                    debug(`Couldn't close target ${tab.id}`);
                }
            }
            try {
                debug(`Closing client`);
                this._client.close();
                if (targets.size === 0 && this._pid) {
                    process.kill(this._pid, 9);
                }
            }
            catch (e) {
                debug(`Couldn't close the client properly`);
            }
        }
        catch (e) {
            {
                debug(`Error while closing`);
                debug(e);
            }
        }
        finally {
            await this.unlockFile();
        }
    }
    fetchContent(target, customHeaders) {
        const href = typeof target === 'string' ? target : target.href;
        const options = {
            headers: customHeaders || {},
            rejectUnauthorized: !this._options.ignoreHTTPSErrors,
            strictSSL: !this._options.ignoreHTTPSErrors
        };
        const request = new utils_connector_tools_1.Requester(options);
        return request.get(href);
    }
    wrapRuntimeEvalErrorInBrowser(e) {
        const err = e || new Error();
        const fallbackMessage = typeof err === 'string' ? err : 'unknown error';
        return {
            __failedInBrowser: true,
            message: err.message || fallbackMessage,
            name: err.name || 'Error',
            stack: err.stack || (new Error()).stack
        };
    }
    evaluate(code) {
        return new Promise(async (resolve, reject) => {
            const asyncTimeout = setTimeout((() => {
                reject(new Error(`The script evaluation exceeded the allotted time of ${this._timeout / 1000}s.`));
            }), this._timeout);
            try {
                const expression = `(function wrapInNativePromise() {
          const __nativePromise = window.__nativePromise || Promise;
          return new __nativePromise(function (resolve) {
            return __nativePromise.resolve()
              .then(_ => ${code})
              .catch(function ${this.wrapRuntimeEvalErrorInBrowser.toString()})
              .then(resolve);
          });
        }())`;
                const result = await this._client.Runtime.evaluate({
                    awaitPromise: true,
                    expression,
                    includeCommandLineAPI: true,
                    returnByValue: true
                });
                clearTimeout(asyncTimeout);
                const value = result.result.value;
                if (result.exceptionDetails) {
                    return reject(new Error('an unexpected driver error occurred'));
                }
                if (value && value.__failedInBrowser) {
                    return reject(Object.assign(new Error(), value));
                }
                return resolve(value);
            }
            catch (err) {
                clearTimeout(asyncTimeout);
                return reject(err);
            }
        });
    }
    querySelectorAll(selector) {
        if (!this._dom) {
            return [];
        }
        return this._dom.querySelectorAll(selector);
    }
    get dom() {
        return this._dom;
    }
    get headers() {
        return this._targetNetworkData &&
            this._targetNetworkData.response &&
            utils_connector_tools_1.normalizeHeaders(this._targetNetworkData.response.headers) ||
            undefined;
    }
    get html() {
        if (!this._dom) {
            return '';
        }
        return this._dom.pageHTML();
    }
}
exports.Connector = Connector;
Connector.schema = {
    additionalProperties: false,
    properties: {
        ignoreHTTPSErrors: { type: 'boolean' },
        launcherOptions: { type: 'object' },
        waitFor: {
            minimum: 0,
            type: 'number'
        }
    }
};
