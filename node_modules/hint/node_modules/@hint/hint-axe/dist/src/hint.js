"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = require("@hint/utils/dist/src/debug");
const read_file_async_1 = require("@hint/utils/dist/src/fs/read-file-async");
const types_1 = require("hint/dist/src/lib/types");
const meta_1 = require("./meta");
const debug = debug_1.debug(__filename);
class AxeHint {
    constructor(context) {
        let axeConfig = { runOnly: ['wcag2a', 'wcag2aa'] };
        const loadHintConfig = () => {
            if (!context.hintOptions) {
                return;
            }
            axeConfig = context.hintOptions;
        };
        const generateScript = () => {
            const script = `function runA11yChecks() {
    return window['axe'].run(document, ${JSON.stringify(axeConfig, null, 2)});
}`;
            return script;
        };
        const getElement = (node) => {
            const selector = node.target[0];
            const elements = context.querySelectorAll(selector);
            return elements[0];
        };
        const validate = async (canEvaluateScript) => {
            const { resource } = canEvaluateScript;
            const axeCore = await read_file_async_1.readFileAsync(require.resolve('axe-core'));
            const script = `(function () {
    ${axeCore};
    return (${generateScript()}());
}())`;
            let result = null;
            try {
                result = await context.evaluate(script);
            }
            catch (e) {
                let message;
                if (e.message.includes('evaluation exceeded')) {
                    message = `webhint did not return the result fast enough`;
                }
                else {
                    message = `Error executing script: '${e.message}'`;
                }
                message = `${message}. Please try again later, or report an issue if this problem persists.`;
                context.report(resource, message, { severity: types_1.Severity.warning });
                debug('Error executing script %O', e);
                return;
            }
            if (!result || !Array.isArray(result.violations)) {
                debug(`Unable to parse axe results ${result}`);
                return;
            }
            if (result.violations.length === 0) {
                debug('No accessibility issues found');
                return;
            }
            result.violations.forEach((violation) => {
                violation.nodes.forEach((node) => {
                    const element = getElement(node);
                    context.report(resource, violation.help, { element });
                });
            }, []);
        };
        loadHintConfig();
        context.on('can-evaluate::script', validate);
    }
}
AxeHint.meta = meta_1.default;
exports.default = AxeHint;
