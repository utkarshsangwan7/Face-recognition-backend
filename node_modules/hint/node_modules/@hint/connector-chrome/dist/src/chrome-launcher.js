"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chromeLauncher = require("chrome-launcher");
const isCI = require("is-ci");
const utils_1 = require("@hint/utils");
const utils_debugging_protocol_common_1 = require("@hint/utils-debugging-protocol-common");
const { readFileAsync, writeFileAsync } = utils_1.fs;
const { delay } = utils_1.misc;
const debug = utils_1.debug(__filename);
class CDPLauncher extends utils_debugging_protocol_common_1.Launcher {
    constructor(options) {
        const flags = options && options.flags || ['--no-default-browser-check'];
        if (isCI) {
            flags.push('--headless', '--disable-gpu');
        }
        else if (process.env.DOCKER === 'true') {
            flags.push('--headless');
        }
        super(Object.assign({}, options, { flags: Array.from(new Set(flags)) }));
        this.chromeFlags = flags;
        this.userDataDir = options && typeof options.defaultProfile === 'boolean' && options.defaultProfile ?
            false :
            '';
        this.port = options && options.port;
    }
    async getBrowserInfo() {
        let result = {
            pid: -1,
            port: this.port
        };
        try {
            result = JSON.parse(await readFileAsync(this.pidFile));
        }
        catch (e) {
            {
                debug(`Error reading ${this.pidFile}`);
                debug(e);
                result = {
                    pid: -1,
                    port: this.port
                };
            }
        }
        if (Number.isNaN(result.pid)) {
            return {
                pid: -1,
                port: this.port
            };
        }
        try {
            await delay(400);
            process.kill(result.pid, 0);
        }
        catch (e) {
            {
                debug(`Process with ${result.pid} doesn't seem to be running`);
                result = {
                    pid: -1,
                    port: this.port
                };
            }
        }
        return result;
    }
    async writePid(browserInfo) {
        await writeFileAsync(this.pidFile, JSON.stringify({ pid: browserInfo.pid, port: browserInfo.port || this.port }, null, 4));
    }
    async launch(url) {
        const currentInfo = await this.getBrowserInfo();
        if (currentInfo.pid !== -1) {
            currentInfo.isNew = false;
            return currentInfo;
        }
        try {
            const chrome = await chromeLauncher.launch({
                chromeFlags: this.chromeFlags,
                connectionPollInterval: 1000,
                logLevel: debug.enabled ? 'verbose' : 'silent',
                port: currentInfo.port,
                startingUrl: url,
                userDataDir: this.userDataDir
            });
            const browserInfo = {
                isNew: true,
                pid: chrome.pid,
                port: chrome.port
            };
            this.port = chrome.port;
            await this.writePid(browserInfo);
            debug('Browser launched correctly');
            return browserInfo;
        }
        catch (e) {
            {
                debug('Error launching browser');
                debug(e);
                throw e;
            }
        }
    }
}
exports.CDPLauncher = CDPLauncher;
