/// <reference types="node" />
import * as url from 'url';
import { EventEmitter2 as EventEmitter } from 'eventemitter2';
import { Events, HintResources, HttpHeaders, IAsyncHTMLElement, IFetchOptions, IFormatter, NetworkData, Problem, ProblemLocation, Severity, StringKeyOf } from './types';
import { Configuration } from './config';
import { Category } from './enums/category';
export declare class Engine<E extends Events = Events> extends EventEmitter {
    private parsers;
    private hints;
    private connector;
    private messages;
    private browserslist;
    private ignoredUrls;
    private _formatters;
    private _timeout;
    readonly pageDOM: object | undefined;
    readonly pageContent: Promise<string> | undefined;
    readonly pageHeaders: HttpHeaders | undefined;
    readonly targetedBrowsers: string[];
    readonly formatters: IFormatter[];
    readonly timeout: number;
    private isIgnored;
    constructor(config: Configuration, resources: HintResources);
    onHintEvent<K extends StringKeyOf<E>>(id: string, eventName: K, listener: (data: E[K], event: string) => void): void;
    fetchContent(target: string | url.URL, headers?: object): Promise<NetworkData>;
    evaluate(source: string): Promise<any>;
    close(): Promise<void>;
    report(hintId: string, category: Category, severity: Severity, sourceCode: string, location: ProblemLocation | null, message: string, resource: string): void;
    clean(fileUrl: url.URL): void;
    clear(): void;
    notify(this: Engine<Events>): Promise<void>;
    executeOn(target: url.URL, options?: IFetchOptions): Promise<Problem[]>;
    querySelectorAll(selector: string): Promise<IAsyncHTMLElement[]>;
    emit<K extends StringKeyOf<E>>(event: K, data: E[K]): boolean;
    emitAsync<K extends StringKeyOf<E>>(event: K, data: E[K]): Promise<any[]>;
    on<K extends StringKeyOf<E>>(event: K, listener: (data: E[K]) => void): this;
}
//# sourceMappingURL=engine.d.ts.map