/// <reference types="node" />
import { URL } from 'url';
import { Engine } from './engine';
import { Events, HintMetadata, IAsyncHTMLElement, NetworkData, ProblemLocation, Severity, StringKeyOf } from './types';
export declare type ReportOptions = {
    codeSnippet?: string;
    content?: string;
    element?: IAsyncHTMLElement | null;
    location?: ProblemLocation | null;
    severity?: Severity;
};
export declare class HintContext<E extends Events = Events> {
    private id;
    private options;
    private meta;
    private severity;
    private engine;
    private ignoredUrls;
    constructor(hintId: string, engine: Engine<E>, severity: Severity, options: any, meta: HintMetadata, ignoredUrls: RegExp[]);
    readonly pageDOM: object | undefined;
    readonly pageContent: Promise<string> | undefined;
    readonly pageHeaders: import("./types").HttpHeaders | undefined;
    readonly targetedBrowsers: string[];
    readonly hintOptions: any;
    evaluate(source: string): Promise<any>;
    fetchContent(target: string | URL, headers?: object): Promise<NetworkData>;
    querySelectorAll(selector: string): Promise<IAsyncHTMLElement[]>;
    findInElement(element: IAsyncHTMLElement, content: string): Promise<ProblemLocation>;
    findProblemLocation(element: IAsyncHTMLElement, content?: string): Promise<ProblemLocation>;
    report(resource: string, message: string, options?: ReportOptions): Promise<void>;
    on<K extends StringKeyOf<E>>(event: K, listener: (data: E[K], event: string) => void): void;
    isUrlIgnored(resource: string): boolean;
}
//# sourceMappingURL=hint-context.d.ts.map