"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = require("./debug");
const debug = debug_1.debug(__filename);
const quotesRegex = /('|")/g;
const escapeQuotes = (text) => {
    return text.replace(quotesRegex, '\\$1');
};
const escapeNamespace = (text) => {
    return text.replace(':', '\\:');
};
const escapeNewline = (text) => {
    return text.replace(/\n(\s)?/g, '\\a $1');
};
const selectorFromElement = (element) => {
    let selector = element.nodeName.toLowerCase();
    const attributes = element.attributes;
    for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i] || attributes.item && attributes.item(i);
        if (!attribute.name.includes('.')) {
            selector += `[${escapeNamespace(attribute.name)}="${escapeQuotes(escapeNewline(attribute.value))}"]`;
        }
    }
    debug(`Selector created: ${selector}`);
    return selector;
};
const getIndicesOf = (searchStr, str) => {
    const searchStrLen = searchStr.length;
    let startIndex = 0;
    let index;
    const indices = [];
    if (searchStr === '') {
        return indices;
    }
    while ((index = str.indexOf(searchStr, startIndex)) > -1) {
        indices.push(index);
        startIndex = index + searchStrLen;
    }
    debug(`Indices found: ${indices.length} (${JSON.stringify(indices)})`);
    return indices;
};
exports.findElementLocation = async (element) => {
    const location = element.getLocation();
    if (location) {
        return location;
    }
    const html = await element.ownerDocument.pageHTML();
    const elementHTML = await element.outerHTML();
    const indexOccurences = getIndicesOf(elementHTML, html);
    const selector = selectorFromElement(element);
    let elements;
    try {
        elements = await element.ownerDocument.querySelectorAll(selector);
    }
    catch (e) {
        debug(`Invalid selector, falling back to start of document: '${selector}'.`);
        return {
            column: 0,
            line: 0
        };
    }
    let similarItems = 0;
    for (let index = 0; index < elements.length; index++) {
        const currentElement = elements[index];
        const currentElementHTML = await currentElement.outerHTML();
        if (currentElementHTML === elementHTML) {
            similarItems++;
            if (element.isSame(currentElement)) {
                break;
            }
        }
    }
    const htmlBeforeElement = html.substring(0, indexOccurences[similarItems - 1]);
    const lines = htmlBeforeElement.split('\n');
    const line = lines.length;
    const column = (lines.pop() || '').replace(/[\t]/g, '    ').length + 1;
    return {
        column,
        line
    };
};
exports.findInElement = async (element, content) => {
    if (!content) {
        return {
            column: 0,
            line: 1
        };
    }
    const outerHTML = await element.outerHTML();
    const startIndex = outerHTML.indexOf(content);
    if (startIndex === -1) {
        return {
            column: -1,
            line: -1
        };
    }
    const html = outerHTML.substring(0, startIndex);
    const lines = html.split('\n');
    const line = lines.length;
    const column = (lines.length === 1 ? startIndex : (lines.pop() || '').replace(/[\t]/g, '    ').length) + 1;
    return {
        column,
        line
    };
};
exports.findProblemLocation = async (element, offset, content) => {
    const elementLocation = await exports.findElementLocation(element);
    const problemLocation = await exports.findInElement(element, content || '');
    if (problemLocation.line === 1) {
        return {
            column: problemLocation.column + elementLocation.column + offset.column,
            elementColumn: problemLocation.column + offset.column,
            elementLine: problemLocation.line + offset.line,
            line: elementLocation.line + offset.line
        };
    }
    return {
        column: (elementLocation.column || problemLocation.column) + offset.column,
        elementColumn: problemLocation.column + offset.column,
        elementLine: problemLocation.line + offset.line,
        line: elementLocation.line + problemLocation.line + offset.line
    };
};
