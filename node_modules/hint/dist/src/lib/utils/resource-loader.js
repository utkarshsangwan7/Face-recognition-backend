"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const child_process_1 = require("child_process");
const globby_1 = require("globby");
const semver = require("semver");
const load_json_file_1 = require("./fs/load-json-file");
const load_package_1 = require("./packages/load-package");
const load_hint_package_1 = require("./packages/load-hint-package");
const find_node_modules_root_1 = require("./packages/find-node-modules-root");
const find_package_root_1 = require("./packages/find-package-root");
const normalize_includes_1 = require("./misc/normalize-includes");
const read_file_1 = require("./fs/read-file");
const debug_1 = require("./debug");
const config_1 = require("../config");
const resource_type_1 = require("../enums/resource-type");
const error_status_1 = require("../enums/error-status");
const resource_error_1 = require("../types/resource-error");
const cwd_1 = require("./fs/cwd");
const debug = debug_1.debug(__filename);
const HINT_ROOT = find_package_root_1.default();
const NODE_MODULES_ROOT = (() => {
    const root = find_node_modules_root_1.default();
    if (root.includes('_npx')) {
        const npmPrefix = child_process_1.execSync('npm prefix -g')
            .toString()
            .trim();
        return path.join(npmPrefix, 'node_modules');
    }
    return root;
})();
const moduleNameRegex = /[^']*'([^']*)'/g;
const resources = new Map();
const resourceIds = new Map();
const loadPackage = (modulePath) => {
    let pkg;
    if (process.env.webpack) {
        pkg = eval(`require("${modulePath}")`);
    }
    else {
        pkg = require(modulePath);
    }
    return pkg;
};
const resolvePackage = (modulePath) => {
    let pkgPath;
    if (process.env.webpack) {
        pkgPath = eval(`require.resolve("${modulePath}")`);
    }
    else {
        pkgPath = require.resolve(modulePath);
    }
    return pkgPath;
};
const isVersionValid = (resourcePath) => {
    try {
        const pkg = load_package_1.default(resourcePath);
        const hintPkg = load_hint_package_1.default();
        return semver.satisfies(hintPkg.version, pkg.peerDependencies.hint);
    }
    catch (e) {
        debug(e);
        return true;
    }
};
exports.getCoreResources = (type) => {
    if (resourceIds.has(type)) {
        return resourceIds.get(type);
    }
    const resourcesFiles = globby_1.sync(`dist/src/lib/${type}s/**/*.js`, { cwd: HINT_ROOT });
    const ids = resourcesFiles.reduce((list, resourceFile) => {
        const resourceName = path.basename(resourceFile, '.js');
        if (path.dirname(resourceFile).includes(resourceName)) {
            list.push(resourceName);
        }
        return list;
    }, []);
    resourceIds.set(type, ids);
    return ids;
};
const hasMultipleResources = (resource, type) => {
    switch (type) {
        case resource_type_1.ResourceType.hint:
            return !resource.meta;
        default:
            return false;
    }
};
exports.getInstalledResources = (type) => {
    const installedType = `installed-${type}`;
    if (resourceIds.has(installedType)) {
        return resourceIds.get(installedType);
    }
    const resourcesFiles = globby_1.sync(`${NODE_MODULES_ROOT}/@hint/${type}-*/package.json`);
    const ids = resourcesFiles.reduce((list, resourceFile) => {
        const resource = loadPackage(path.dirname(resourceFile));
        const packageName = JSON.parse(read_file_1.default(resourceFile)).name;
        const resourceName = packageName.substr(packageName.lastIndexOf('/') + 1).replace(`${type}-`, '');
        if (!hasMultipleResources(resource, type)) {
            list.push(resourceName);
        }
        else {
            const hints = Object.entries(resource);
            if (hints.length === 1 && resource[resourceName]) {
                list.push(resourceName);
            }
            else {
                for (const [key] of hints) {
                    list.push(`${resourceName}/${key}`);
                }
            }
        }
        return list;
    }, []);
    resourceIds.set(installedType, ids);
    return ids;
};
exports.tryToLoadFrom = (resourcePath) => {
    let builder = null;
    try {
        const resource = load_json_file_1.default(resourcePath);
        return resource;
    }
    catch (e) {
        debug(`${resourcePath} is not a JSON file, trying to load it normally`);
    }
    try {
        const resource = loadPackage(resourcePath);
        builder = resource.default || resource;
    }
    catch (e) {
        debug(`Can't require ${resourcePath}`);
        if (e.code === 'MODULE_NOT_FOUND') {
            const exec = moduleNameRegex.exec(e.message);
            const moduleName = exec ? exec[1] : null;
            if (!moduleName || moduleName === resourcePath) {
                return null;
            }
            const errorMessage = `Module ${moduleName} not found when loading ${resourcePath}`;
            throw new resource_error_1.ResourceError(errorMessage, error_status_1.ResourceErrorStatus.DependencyError);
        }
        throw new resource_error_1.ResourceError(e, error_status_1.ResourceErrorStatus.Unknown);
    }
    return builder;
};
const getResource = (source, type, name) => {
    const resource = exports.tryToLoadFrom(source);
    if (!resource) {
        return null;
    }
    if (!hasMultipleResources(resource, type)) {
        return resource;
    }
    for (const [key, value] of Object.entries(resource)) {
        if (key === name) {
            return value.default || value;
        }
    }
    return null;
};
const generateConfigPathsToResources = (configurations, name, type) => {
    return configurations.reduce((total, configuration) => {
        const basePackagePaths = ['@hint/configuration-', 'hint-configuration-'];
        let result = total;
        for (const basePackagePath of basePackagePaths) {
            const packageName = `${basePackagePath}${configuration}`;
            try {
                const packagePath = path.dirname(resolvePackage(packageName));
                const resourcePackages = globby_1.sync(`node_modules/{@hint/,hint-}${type}-${name}/package.json`, { absolute: true, cwd: packagePath }).map((pkg) => {
                    return path.dirname(pkg);
                });
                result = result.concat(resourcePackages);
            }
            catch (err) {
                debug(`Package ${packageName} not found`);
            }
        }
        return result;
    }, []);
};
exports.loadResource = (name, type, configurations = [], verifyVersion = false) => {
    debug(`Searching ${name}â€¦`);
    const isSource = fs.existsSync(name);
    const nameSplitted = name.split('/');
    const packageName = nameSplitted[0];
    const resourceName = isSource ?
        name :
        nameSplitted[1] || packageName;
    const key = isSource ?
        name :
        `${type}-${name}`;
    if (resources.has(key) && !verifyVersion) {
        return resources.get(key);
    }
    const configPathsToResources = generateConfigPathsToResources(configurations, packageName, type);
    const currentProcessDir = cwd_1.default();
    const sources = isSource ?
        [path.resolve(currentProcessDir, name)] :
        [
            `@hint/${type}-${packageName}`,
            `webhint-${type}-${packageName}`,
            path.normalize(`${HINT_ROOT}/dist/src/lib/${type}s/${packageName}/${packageName}.js`),
            path.normalize(currentProcessDir)
        ].concat(configPathsToResources);
    let resource;
    let loadedSource;
    let isValid = true;
    sources.some((source) => {
        const res = getResource(source, type, resourceName);
        if (res && isSource) {
            isValid = true;
            resource = res;
            loadedSource = source;
            return true;
        }
        if (res && !isSource) {
            debug(`${name} found in ${source}`);
            if (source === currentProcessDir) {
                try {
                    const packageConfig = load_package_1.default(source);
                    if (!normalize_includes_1.default(packageConfig.name, packageName)) {
                        return false;
                    }
                }
                catch (e) {
                    return false;
                }
            }
            if (verifyVersion && !isVersionValid(source)) {
                debug(`Resource ${name} isn't compatible with current hint version`);
                isValid = false;
                return false;
            }
            isValid = true;
            resource = res;
            loadedSource = source;
        }
        return resource;
    });
    if (!isValid) {
        throw new resource_error_1.ResourceError(`Resource ${name} isn't compatible with current hint version`, error_status_1.ResourceErrorStatus.NotCompatible);
    }
    if (!resource) {
        debug(`Resource ${name} not found`);
        throw new resource_error_1.ResourceError(`Resource ${name} not found`, error_status_1.ResourceErrorStatus.NotFound);
    }
    if (type === resource_type_1.ResourceType.configuration) {
        resource = config_1.Configuration.toAbsolutePaths(resource, resolvePackage(loadedSource));
    }
    resources.set(key, resource);
    return resource;
};
const loadListOfResources = (list = [], type, configurations = []) => {
    const missing = [];
    const incompatible = [];
    const items = Array.isArray(list) ?
        list :
        Object.keys(list);
    const loadedResources = items.reduce((loaded, resourceId) => {
        try {
            const resource = exports.loadResource(resourceId, type, configurations, true);
            loaded.push(resource);
        }
        catch (e) {
            if (e.status === error_status_1.ResourceErrorStatus.NotCompatible) {
                incompatible.push(`${type}-${resourceId}`);
            }
            else if (e.status === error_status_1.ResourceErrorStatus.NotFound) {
                missing.push(`${type}-${resourceId}`);
            }
            else {
                throw e;
            }
        }
        return loaded;
    }, []);
    return {
        incompatible,
        missing,
        resources: loadedResources
    };
};
exports.loadHint = (hintId, configurations) => {
    return exports.loadResource(hintId, resource_type_1.ResourceType.hint, configurations);
};
exports.loadConfiguration = (configurationId, configurations) => {
    return exports.loadResource(configurationId, resource_type_1.ResourceType.configuration, configurations);
};
exports.loadResources = (config) => {
    let connector = null;
    const connectorName = config.connector && config.connector.name || '';
    try {
        connector = exports.loadResource(connectorName, resource_type_1.ResourceType.connector, config.extends, true);
    }
    catch (e) {
        debug(e);
        if (e.status === error_status_1.ResourceErrorStatus.DependencyError) {
            throw e;
        }
    }
    const { incompatible: incompatibleHints, resources: hints, missing: missingHints } = loadListOfResources(config.hints, resource_type_1.ResourceType.hint, config.extends);
    const { incompatible: incompatibleParsers, resources: parsers, missing: missingParsers } = loadListOfResources(config.parsers, resource_type_1.ResourceType.parser, config.extends);
    const { incompatible: incompatibleFormatters, resources: formatters, missing: missingFormatters } = loadListOfResources(config.formatters, resource_type_1.ResourceType.formatter, config.extends);
    const missing = [].concat(missingHints, missingParsers, missingFormatters);
    const incompatible = [].concat(incompatibleFormatters, incompatibleParsers, incompatibleHints);
    if (!connector) {
        missing.push(`${resource_type_1.ResourceType.connector}-${connectorName || config.connector}`);
    }
    return {
        connector,
        formatters,
        hints,
        incompatible,
        missing,
        parsers
    };
};
