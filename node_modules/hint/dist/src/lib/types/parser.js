"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const lodash_1 = require("lodash");
const as_uri_1 = require("../utils/network/as-uri");
const as_path_string_1 = require("../utils/network/as-path-string");
const load_json_file_1 = require("../utils/fs/load-json-file");
class Parser {
    constructor(engine, parseEventType) {
        this.engine = engine;
        this.name = parseEventType;
    }
    finalConfig(config, resource) {
        if (!config.extends) {
            return config;
        }
        const configIncludes = new Set();
        let configPath = as_path_string_1.default(as_uri_1.getAsUri(resource));
        configIncludes.add(path.normalize(configPath));
        let finalConfigJSON = lodash_1.merge({}, config);
        while (finalConfigJSON.extends) {
            const lastPath = configPath;
            const configDir = path.dirname(configPath);
            configPath = path.resolve(configDir, finalConfigJSON.extends);
            if (configIncludes.has(configPath)) {
                const error = new Error(`Circular reference found in file ${lastPath}`);
                const lastPathUri = as_uri_1.getAsUri(lastPath);
                error.resource = lastPathUri && lastPathUri.toString() || lastPath;
                return error;
            }
            delete finalConfigJSON.extends;
            try {
                const extendedConfig = load_json_file_1.default(configPath);
                console.log(`adding: ${configPath}`);
                configIncludes.add(configPath);
                finalConfigJSON = lodash_1.merge({}, extendedConfig, finalConfigJSON);
            }
            catch (err) {
                const lastPathUri = as_uri_1.getAsUri(lastPath);
                err.resource = lastPathUri && lastPathUri.toString() || lastPath;
                return err;
            }
        }
        return finalConfigJSON;
    }
}
exports.Parser = Parser;
