"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const path = require("path");
const async = require("async");
const ora_1 = require("ora");
const boxen = require('boxen');
const chalk = require("chalk");
const isCI = require("is-ci");
const configStore = require("../utils/config-store");
const config_1 = require("../config");
const engine_1 = require("../engine");
const types_1 = require("../types");
const debug_1 = require("../utils/debug");
const as_uri_1 = require("../utils/network/as-uri");
const logger = require("../utils/logging");
const ask_question_1 = require("../utils/misc/ask-question");
const cut_string_1 = require("../utils/misc/cut-string");
const resourceLoader = require("../utils/resource-loader");
const npm_1 = require("../utils/npm");
const insights = require("../utils/app-insights");
const load_hint_package_1 = require("../utils/packages/load-hint-package");
const each = util_1.promisify(async.each);
const debug = debug_1.debug(__filename);
const configStoreKey = 'run';
const printFrame = (message) => {
    logger.log(boxen(message, {
        align: 'center',
        margin: 1,
        padding: 1
    }));
};
const showTelemetryMessage = () => {
    const message = `Help us improve webhint
by sending limited usage information
(no personal information or URLs will be sent).

To know more about what information will be sent please
visit ${chalk.default.green('https://webhint.io/docs/user-guide/telemetry')}`;
    printFrame(message);
};
const showCITelemetryMessage = () => {
    const message = `Help us improve webhint
by sending limited usage information
(no personal information or URLs will be sent).

To know more about what information will be sent please
visit ${chalk.default.green('https://webhint.io/docs/user-guide/telemetry')}

Please configure it using
the environment variable HINT_TRACKING to 'on' or 'off'
or set the flag --tracking=on|off`;
    printFrame(message);
};
const askForTelemetryConfirmation = async (config) => {
    if (insights.isConfigured()) {
        return;
    }
    if (isCI) {
        if (!insights.isConfigured()) {
            showCITelemetryMessage();
        }
        return;
    }
    const alreadyRun = configStore.get(configStoreKey);
    if (!alreadyRun) {
        configStore.set(configStoreKey, true);
        return;
    }
    showTelemetryMessage();
    const message = `Do you want to opt-in?`;
    debug(`Prompting telemetry permission.`);
    const confirm = await ask_question_1.default(message);
    if (confirm) {
        insights.enable();
        insights.trackEvent('SecondRun');
        insights.trackEvent('analyze', config);
        return;
    }
    insights.disable();
};
const askUserToUseDefaultConfiguration = async () => {
    const question = `A valid configuration file can't be found. Do you want to use the default configuration? To know more about the default configuration see: https://webhint.io/docs/user-guide/#default-configuration`;
    const confirmation = await ask_question_1.default(question);
    return confirmation;
};
const showMissingAndIncompatiblePackages = (resources) => {
    if (resources.missing.length > 0) {
        logger.log(`The following ${resources.missing.length === 1 ? 'package is' : 'packages are'} missing:
    ${resources.missing.join(', ')}`);
    }
    if (resources.incompatible.length > 0) {
        logger.log(`The following ${resources.incompatible.length === 1 ? 'package is' : 'packages are'} incompatible:
    ${resources.incompatible.join(', ')}`);
    }
};
const askUserToInstallDependencies = async (resources) => {
    showMissingAndIncompatiblePackages(resources);
    const dependencies = resources.incompatible.concat(resources.missing);
    const question = `There ${dependencies.length === 1 ? 'is a package' : 'are packages'} from your .hintrc file not installed or with an incompatible version. Do you want us to try to install/update them?`;
    const answer = await ask_question_1.default(question);
    return answer;
};
const showDefaultMessage = () => {
    const defaultMessage = `${chalk.default.yellow(`Couldn't find any valid configuration`)}

Running hint with the default configuration.

Learn more about how to create your own configuration at:

${chalk.default.green('https://webhint.io/docs/user-guide/')}`;
    printFrame(defaultMessage);
};
const getDefaultConfiguration = () => {
    showDefaultMessage();
    return { extends: ['web-recommended'] };
};
const getUserConfig = (actions) => {
    const configPath = (actions && actions.config) || config_1.Configuration.getFilenameForDirectory(process.cwd());
    if (!configPath) {
        return getDefaultConfiguration();
    }
    debug(`Loading configuration file from ${configPath}.`);
    try {
        const resolvedPath = path.resolve(process.cwd(), configPath);
        const config = config_1.Configuration.loadConfigFile(resolvedPath);
        return config || getDefaultConfiguration();
    }
    catch (e) {
        logger.error(e);
        return null;
    }
};
const messages = {
    'fetch::end': '%url% downloaded',
    'fetch::start': 'Downloading %url%',
    'scan::end': 'Finishing...',
    'scan::start': 'Analyzing %url%',
    'traverse::down': 'Traversing the DOM',
    'traverse::end': 'Traversing finished',
    'traverse::start': 'Traversing the DOM',
    'traverse::up': 'Traversing the DOM'
};
const getEvent = (event) => {
    if (event.startsWith('fetch::end')) {
        return 'fetch::end';
    }
    return event;
};
const setUpUserFeedback = (engine, spinner) => {
    engine.prependAny(((event, value) => {
        const message = messages[getEvent(event)];
        if (!message) {
            return;
        }
        spinner.text = message.replace('%url%', cut_string_1.default(value.resource));
    }));
};
const getDefaultOrCreateConfig = async (actions) => {
    const useDefault = await askUserToUseDefaultConfiguration();
    let userConfig;
    if (useDefault) {
        userConfig = getDefaultConfiguration();
    }
    else {
        logger.error(`Unable to find a valid configuration file. Please create a valid .hintrc file using 'npm init hintrc'.`);
        return null;
    }
    return config_1.Configuration.fromConfig(userConfig, actions);
};
const getHintConfiguration = async (userConfig, actions) => {
    if (!userConfig) {
        return getDefaultOrCreateConfig(actions);
    }
    let config;
    try {
        config = config_1.Configuration.fromConfig(userConfig, actions);
    }
    catch (err) {
        logger.error(err.message);
        config = await getDefaultOrCreateConfig(actions);
    }
    return config;
};
exports.engine = null;
exports.default = async (actions) => {
    const targets = as_uri_1.getAsUris(actions._);
    if (targets.length === 0) {
        return false;
    }
    const userConfig = await getUserConfig(actions);
    const config = await getHintConfiguration(userConfig, actions);
    if (!config) {
        return false;
    }
    let resources = resourceLoader.loadResources(config);
    insights.trackEvent('analyze', config);
    if (resources.missing.length > 0 || resources.incompatible.length > 0) {
        if (resources.missing.length > 0) {
            insights.trackEvent('missing', resources.missing);
        }
        if (resources.incompatible.length > 0) {
            insights.trackEvent('incompatible', resources.incompatible);
        }
        const missingPackages = resources.missing.map((name) => {
            return `@hint/${name}`;
        });
        const incompatiblePackages = resources.incompatible.map((name) => {
            return `@hint/${name}@latest`;
        });
        if (!(await askUserToInstallDependencies(resources) &&
            await npm_1.installPackages(missingPackages) &&
            await npm_1.installPackages(incompatiblePackages))) {
            return false;
        }
        resources = resourceLoader.loadResources(config);
    }
    const invalidConfigHints = config_1.Configuration.validateHintsConfig(config).invalid;
    if (invalidConfigHints.length > 0) {
        logger.error(`Invalid hint configuration in .hintrc: ${invalidConfigHints.join(', ')}.`);
        return false;
    }
    exports.engine = new engine_1.Engine(config, resources);
    const start = Date.now();
    const spinner = ora_1.default({ spinner: 'line' });
    let exitCode = 0;
    if (!actions.debug) {
        spinner.start();
        setUpUserFeedback(exports.engine, spinner);
    }
    const endSpinner = (method) => {
        if (!actions.debug && spinner[method]) {
            spinner[method]();
        }
    };
    const hasError = (reports) => {
        return reports.some((result) => {
            return result.severity === types_1.Severity.error;
        });
    };
    const print = async (reports, target, scanTime, date) => {
        const formatterOptions = {
            config: userConfig || undefined,
            date,
            resources,
            scanTime,
            version: load_hint_package_1.default().version
        };
        if (exports.engine) {
            await each(exports.engine.formatters, async (formatter) => {
                await formatter.format(reports, target, formatterOptions);
            });
        }
    };
    exports.engine.on('print', print);
    for (const target of targets) {
        try {
            const scanStart = Date.now();
            const results = await exports.engine.executeOn(target);
            const scanEnd = Date.now();
            if (hasError(results)) {
                exitCode = 1;
            }
            endSpinner(exitCode ? 'fail' : 'succeed');
            await askForTelemetryConfirmation(config);
            await print(results, target.href, scanEnd - scanStart, new Date(scanStart).toISOString());
        }
        catch (e) {
            exitCode = 1;
            endSpinner('fail');
            debug(`Failed to analyze: ${target.href}`);
            debug(e);
        }
    }
    await exports.engine.close();
    debug(`Total runtime: ${Date.now() - start}ms`);
    return exitCode === 0;
};
