"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const browserslist = require("browserslist");
const lodash_1 = require("lodash");
const debug_1 = require("./utils/debug");
const is_file_1 = require("./utils/fs/is-file");
const load_js_file_1 = require("./utils/fs/load-js-file");
const load_json_file_1 = require("./utils/fs/load-json-file");
const config_validator_1 = require("./config/config-validator");
const normalize_hints_1 = require("./config/normalize-hints");
const config_hints_1 = require("./config/config-hints");
const logger = require("./utils/logging");
const resourceLoader = require("./utils/resource-loader");
const debug = debug_1.debug(__filename);
const CONFIG_FILES = [
    '.hintrc',
    '.hintrc.js',
    '.hintrc.json',
    'package.json'
];
const loadPackageJSONConfigFile = (filePath) => {
    debug(`Loading package.json config file: ${filePath}`);
    try {
        return load_json_file_1.default(filePath).hintConfig || null;
    }
    catch (e) {
        debug(`Error reading package.json file: ${filePath}`);
        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
        throw e;
    }
};
const composeConfig = (userConfig, parentConfig = '') => {
    debug('Composing configuration from extends');
    if (!userConfig.extends || !Array.isArray(userConfig.extends) || userConfig.extends.length === 0) {
        return userConfig;
    }
    const configurations = userConfig.extends.map((config) => {
        const loadedConfiguration = resourceLoader.loadConfiguration(config, [parentConfig]);
        if (!config_validator_1.validateConfig(loadedConfiguration)) {
            throw new Error(`Configuration package "${config}" is not valid`);
        }
        return composeConfig(loadedConfiguration, config);
    });
    const finalConfig = lodash_1.mergeWith({}, ...configurations, userConfig, (objValue, srcValue) => {
        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
            return objValue.concat(srcValue);
        }
        return void 0;
    });
    finalConfig.formatters = userConfig.formatters ? userConfig.formatters : finalConfig.formatters;
    if (finalConfig.parsers) {
        finalConfig.parsers = Array.from(new Set(finalConfig.parsers));
    }
    return finalConfig;
};
const loadIgnoredUrls = (userConfig) => {
    debug('Initializing ignored urls');
    const ignoredUrls = new Map();
    if (userConfig.ignoredUrls) {
        userConfig.ignoredUrls.forEach((ignoredUrl) => {
            const { domain: urlRegexString, hints } = ignoredUrl;
            hints.forEach((hint) => {
                const hintName = hint === '*' ? 'all' : hint;
                const urlsInHint = ignoredUrls.get(hintName);
                const urlRegex = new RegExp(urlRegexString, 'i');
                if (!urlsInHint) {
                    ignoredUrls.set(hintName, [urlRegex]);
                }
                else {
                    urlsInHint.push(urlRegex);
                }
            });
        });
    }
    return ignoredUrls;
};
const buildHintsConfigFromHintNames = (hintNames, severity) => {
    const hintConfig = {};
    for (const hintName of hintNames) {
        hintConfig[hintName] = severity;
    }
    return hintConfig;
};
const updateConfigWithCommandLineValues = (config, actions) => {
    debug('overriding config settings with values provided via CLI');
    if (actions && actions.formatters) {
        config.formatters = actions.formatters.split(',');
        debug(`Using formatters option provided from command line: ${actions.formatters}`);
    }
    if (actions && actions.hints) {
        const hintNames = actions.hints.split(',');
        config.hints = buildHintsConfigFromHintNames(hintNames, 'error');
        debug(`Using hints option provided from command line: ${actions.hints}`);
    }
};
class Configuration {
    constructor(userConfig, browsers, ignoredUrls, hints) {
        this.browserslist = browsers;
        this.formatters = userConfig.formatters;
        this.ignoredUrls = ignoredUrls;
        this.parsers = userConfig.parsers;
        this.hints = hints;
        this.extends = userConfig.extends;
        this.hintsTimeout = userConfig.hintsTimeout || 60000;
        if (typeof userConfig.connector === 'string') {
            this.connector = {
                name: userConfig.connector,
                options: {}
            };
        }
        else {
            this.connector = userConfig.connector;
        }
    }
    static cleanHints(hints) {
        return Object.entries(hints).reduce((total, [key, value]) => {
            if (config_hints_1.getSeverity(value)) {
                total[key] = value;
            }
            return total;
        }, {});
    }
    static loadBrowsersList(config) {
        logger.warn('`Configuration.loadBrowsersList` is deprecated. Use `Configuration.fromConfig` instead.');
        const directory = process.cwd();
        const files = CONFIG_FILES.reduce((total, configFile) => {
            const filename = path.join(directory, configFile);
            if (is_file_1.default(filename)) {
                total.push(filename);
            }
            return total;
        }, []);
        if (!config.browserslist) {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const tmpConfig = Configuration.loadConfigFile(file);
                if (tmpConfig && tmpConfig.browserslist) {
                    config.browserslist = tmpConfig.browserslist;
                    break;
                }
                if (file.endsWith('package.json')) {
                    const packagejson = load_json_file_1.default(file);
                    config.browserslist = packagejson.browserslist;
                }
            }
        }
        if (!config.browserslist || config.browserslist.length === 0) {
            return browserslist();
        }
        return browserslist(config.browserslist);
    }
    static loadConfigFile(filePath) {
        let config;
        switch (path.extname(filePath)) {
            case '':
            case '.json':
                if (path.basename(filePath) === 'package.json') {
                    config = loadPackageJSONConfigFile(filePath);
                }
                else {
                    config = load_json_file_1.default(filePath);
                }
                break;
            case '.js':
                config = load_js_file_1.default(filePath);
                break;
            default:
                config = null;
        }
        config = this.toAbsolutePaths(config, filePath);
        return config;
    }
    static toAbsolutePaths(config, configRoot) {
        if (!config) {
            return null;
        }
        const stat = fs.statSync(configRoot);
        const configPath = stat.isDirectory() ? configRoot : path.dirname(configRoot);
        if (!configPath) {
            return config;
        }
        const resolve = (value) => {
            if (!value.startsWith('.')) {
                return value;
            }
            return path.resolve(configPath, value);
        };
        if (config.connector) {
            if (typeof config.connector === 'string') {
                config.connector = resolve(config.connector);
            }
            else {
                config.connector.name = resolve(config.connector.name);
            }
        }
        if (config.extends) {
            config.extends = config.extends.map(resolve);
        }
        if (config.formatters) {
            config.formatters = config.formatters.map(resolve);
        }
        if (config.parsers) {
            config.parsers = config.parsers.map(resolve);
        }
        if (config.hints) {
            const hints = Object.keys(config.hints);
            const transformedHints = hints.reduce((newHints, currentHint) => {
                const newHint = resolve(currentHint);
                newHints[newHint] = config.hints[currentHint];
                return newHints;
            }, {});
            config.hints = transformedHints;
        }
        return config;
    }
    static fromConfig(config, actions) {
        if (!config) {
            throw new Error(`Couldn't find a configuration file`);
        }
        if (!config_validator_1.validateConfig(config)) {
            throw new Error(`Couldn't find any valid configuration`);
        }
        const userConfig = composeConfig(config);
        if (typeof userConfig.connector === 'string') {
            userConfig.connector = {
                name: userConfig.connector,
                options: {}
            };
        }
        if (actions && actions.watch && userConfig.connector && userConfig.connector.options) {
            userConfig.connector.options.watch = actions.watch;
        }
        updateConfigWithCommandLineValues(userConfig, actions);
        if (userConfig.formatters && !Array.isArray(userConfig.formatters)) {
            userConfig.formatters = [userConfig.formatters];
        }
        const browsers = browserslist(config.browserslist);
        const ignoredUrls = loadIgnoredUrls(userConfig);
        const hints = Configuration.cleanHints(normalize_hints_1.default(userConfig.hints));
        return new Configuration(userConfig, browsers, ignoredUrls, hints);
    }
    static validateHintsConfig(config) {
        const hints = Object.keys(config.hints);
        const validateResult = hints.reduce((result, hint) => {
            const Hint = resourceLoader.loadHint(hint, config.extends);
            const valid = config_hints_1.validate(Hint.meta, config.hints[hint], hint);
            if (!valid) {
                result.invalid.push(hint);
            }
            else {
                result.valid.push(hint);
            }
            return result;
        }, { invalid: [], valid: [] });
        return validateResult;
    }
    static fromFilePath(filePath, actions) {
        logger.warn('`Configuration.fromFilePath` is deprecated. Use `Configuration.loadConfigFile` with `Configuration.fromConfig` instead.');
        const resolvedPath = path.resolve(process.cwd(), filePath);
        const userConfig = Configuration.loadConfigFile(resolvedPath);
        const config = this.fromConfig(userConfig, actions);
        if (userConfig) {
            userConfig.browserslist = userConfig.browserslist || Configuration.loadBrowsersList(userConfig);
        }
        return config;
    }
}
Configuration.getFilenameForDirectory = (directory) => {
    for (let i = 0, len = CONFIG_FILES.length; i < len; i++) {
        const filename = path.join(directory, CONFIG_FILES[i]);
        if (is_file_1.default(filename)) {
            return filename;
        }
    }
    const homedir = os.homedir();
    if (directory === homedir) {
        return null;
    }
    return Configuration.getFilenameForDirectory(homedir);
};
exports.Configuration = Configuration;
